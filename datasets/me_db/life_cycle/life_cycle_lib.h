// Library for processing Life Cycle CSV files.
//
// LifeCycle exports data as comma separated values with the following schema:
//
//     START DATE(UTC)     Datetime encoded in "%Y-%m-%d %H:%M%S" format.
//     END DATE(UTC)       Datetime encoded in "%Y-%m-%d %H:%M%S" format.
//     START TIME(LOCAL)   Datetime encoded in "%Y-%m-%d %H:%M%S %Z" format.
//     END TIME(LOCAL)     Datetime encoded in "%Y-%m-%d %H:%M%S %Z" format.
//     DURATION            The difference between start and end time in seconds.
//     NAME (optional)     The "What did you do?" category name.
//     LOCATION (optional) The "Where were you?" location name.
//     NOTE (optional)     The contents of the "notes" field.
//
// For the three optional columns, if no value is present, the field is empty.
// The file begins with a header containing the 8 columns names, then an empty
// line.
//
// Lines are delimited using Windows-style '\r\n' returns.
//
// From what I can see, there is no quoting in the CSV, but I haven't tested
// what happens if if NAME/LOCATION/NOTE fields contain commas.
//
// The "START DATE" and "END DATE" for entries can be on different dates.
//
// The SeriesCollection generated by this program contains one series for each
// NAME. The following schema is used:
//
//     Series.name        "${NAME}Time"
//     Series.family      "TimeTracking"
//     Series.unit        "milliseconds"
//     Measurement.group  "${LOCATION}", if set, else "default"
//     Measurement.ms_since_unix_epoch  The START DATE (see below).
//     Measurement.value  END DATE - START DATE in milliseconds (see below).
//     Measurement.source "LifeCycle"
//
// If the entry has a start date different from the end date, it is split into
// multiple Measurements, one per day. This is to ensure that summing the
// measurements for a day is always <= 24 hours. For example, an entry has a
// start date of 2017-01-01 18:00, and an end date of 2017-01-03 12:00, three
// measurements will be created:
//
//     1.  2017-01-01 18:00 - 2017-01-02 00:00
//     2.  2017-01-02 00:00 - 2017-01-03 00:00
//     3.  2017-01-03 00:00 - 2017-01-03 12:00
//
// The NOTE field is not exported.
//
#pragma once

#include "phd/macros.h"
#include "phd/string.h"

#include "datasets/me_db/me.pb.h"

#include "absl/strings/str_cat.h"
#include "absl/strings/str_split.h"
#include "absl/time/time.h"
#include "absl/container/flat_hash_map.h"

#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

namespace me {

template<typename K, typename V>
V FindOrAdd(absl::flat_hash_map<K, V>* map, const K& key,
            std::function<V(const K&)> add_callback) {
  auto it = map->find(key);

  if (it == map->end()) {
    return add_callback(key);
  } else {
    return it->second;
  }
}


// Round a timestamp, as milliseconds since the epoch in UTC, up to the "zeroth"
// millisecond of the next day.
int64_t RoundToStartOfNextDay(const int64_t ms_since_unix_epoch);


// Parse a (START|END)_DATE or (START|END)_TIME column to an absl::Time
// instance, or fatally error.
absl::Time ParseLifeCycleDatetimeOrDie(const string& date);


// Convert an absl::Time instance to the number of milliseconds since the Unix
// epoch.
int64_t ToMillisecondsSinceUnixEpoch(const absl::Time& time);


// Create measurements for the duration. If the duration overflows to
// subsequent dates, it is split into multiple Measurements, one per day.
// This means that summing the measurements for a day is always <= 24 hours.
void AddMeasurementsFromDurationOrDie(int64_t start_time, int64_t end_time,
                                      const string& group, Series* series);

string LocationToGroup(const string& location);

// Process a line from a LifeCycle CSV file and add Measurement(s) to Series
// map. Each line produces one or more Measurements.
void ProcessLineOrDie(
    const std::string& line, const int64_t line_num,
    const boost::filesystem::path csv_path, SeriesCollection* const proto,
    absl::flat_hash_map<string, Series*>* const name_to_series_map);


// Process a SeriesCollection. The input message
// Any errors will lead to fatal program crash.
void ProcessSeriesCollectionOrDie(SeriesCollection* proto);

}  // namespace me
