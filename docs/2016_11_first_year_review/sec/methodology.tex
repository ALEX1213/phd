\section{Methodology}

Use geometric mean for speedups~\cite{Fleming1986}. Statistical
rigour\cite{Georges2007}. Execution times and
variance~\cite{Box}. Benchmarking parallel computing
systems~\cite{Belli2015}.


\subsection{Skeleton-aware compiler optimizations}

First steps:
%
\begin{enumerate}
  \item Write a test case program
  \item Compile to bytecode and check optimisation is not applied
  \item Implement optimisation by hand to source code
  \item Measure performance improvement
  \item Implement compiler pass to apply optimisation to bytecode
  \item Test on real world benchmarks
\end{enumerate}
%
Example: constant propagation across muscle functions in pipe:
%
\begin{enumerate}
  \item Write a pipeline of 100 "+1” functions.
  \item Compile to bytecode and check that pipeline isn’t collapsed.
  \item Collapse pipeline to single stage.
  \item Measure performance improvement.
  \item Implement compiler pass to apply optimisation to bytecode.
  \item Test on real world benchmarks.
\end{enumerate}
%
Next step: load balancing across pipelines - stream partitioning?

Related work: dataflow analysis across skeletons for scheduling, what
kind of optimisations are applied in TLB/actor frameworks, actors in
scala


\subsection{Skeleton-aware debugging}
debugging+profiling for checkpointing

TBB debugging

exoskeleton

SkePU related workx
