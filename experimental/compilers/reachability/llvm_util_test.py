"""Unit tests for //experimental/compilers/reachability:llvm_util."""
import sys

import pyparsing
import pytest
from absl import app
from absl import flags

from compilers.llvm import opt
from experimental.compilers.reachability import llvm_util


FLAGS = flags.FLAGS

# Bytecode generated by clang using the following command:
# $ clang -emit-llvm -S -xc - < foo.c -o - > foo.ll
# Original C source code:
#
#     #include <stdio.h>
#     #include <math.h>
#
#     int DoSomething(int a, int b) {
#       if (a % 5) {
#         return a * 10;
#       }
#       return pow((float)a, 2.5);
#     }
#
#     int main(int argc, char **argv) {
#       for (int i = 0; i < argc; ++i) {
#         argc += DoSomething(argc, i);
#       }
#
#       printf("Computed value %d", argc);
#       return 0;
#     }
SIMPLE_C_BYTECODE = """
; ModuleID = '-'
source_filename = "-"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.12.0"

@.str = private unnamed_addr constant [18 x i8] c"Computed value %d\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @DoSomething(i32, i32) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  store i32 %0, i32* %4, align 4
  store i32 %1, i32* %5, align 4
  %6 = load i32, i32* %4, align 4
  %7 = srem i32 %6, 5
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9                                       ; preds = %2
  %10 = load i32, i32* %4, align 4
  %11 = mul nsw i32 %10, 10
  store i32 %11, i32* %3, align 4
  br label %18

; <label>:12                                      ; preds = %2
  %13 = load i32, i32* %4, align 4
  %14 = sitofp i32 %13 to float
  %15 = fpext float %14 to double
  %16 = call double @llvm.pow.f64(double %15, double 2.500000e+00)
  %17 = fptosi double %16 to i32
  store i32 %17, i32* %3, align 4
  br label %18

; <label>:18                                      ; preds = %12, %9
  %19 = load i32, i32* %3, align 4
  ret i32 %19
}

; Function Attrs: nounwind readnone
declare double @llvm.pow.f64(double, double) #1

; Function Attrs: nounwind ssp uwtable
define i32 @main(i32, i8**) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = alloca i32, align 4
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  store i32 0, i32* %6, align 4
  br label %7

; <label>:7                                       ; preds = %17, %2
  %8 = load i32, i32* %6, align 4
  %9 = load i32, i32* %4, align 4
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %11, label %20

; <label>:11                                      ; preds = %7
  %12 = load i32, i32* %4, align 4
  %13 = load i32, i32* %6, align 4
  %14 = call i32 @DoSomething(i32 %12, i32 %13)
  %15 = load i32, i32* %4, align 4
  %16 = add nsw i32 %15, %14
  store i32 %16, i32* %4, align 4
  br label %17

; <label>:17                                      ; preds = %11
  %18 = load i32, i32* %6, align 4
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* %6, align 4
  br label %7

; <label>:20                                      ; preds = %7
  %21 = load i32, i32* %4, align 4
  %22 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 %21)
  ret i32 0
}

declare i32 @printf(i8*, ...) #2

attributes #0 = { nounwind ssp uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"PIC Level", i32 2}
!1 = !{!"Apple LLVM version 8.0.0 (clang-800.0.42.1)"}
"""

# LLVM-generated dot file for the DoSomething() function of a simple C program.
# Original C source code:
#
#     #include <stdio.h>
#     #include <math.h>
#
#     int DoSomething(int a, int b) {
#       if (a % 5) {
#         return a * 10;
#       }
#       return pow((float)a, 2.5);
#     }
#
#     int main(int argc, char **argv) {
#       for (int i = 0; i < argc; ++i) {
#         argc += DoSomething(argc, i);
#       }
#
#       printf("Computed value %d", argc);
#       return 0;
#     }
#
# I converted tabs to spaces in the following string.
SIMPLE_C_DOT = """
digraph "CFG for 'DoSomething' function" {
  label="CFG for 'DoSomething' function";
  
  Node0x7f86c670c590 [shape=record,label="{%2:\l  %3 = alloca i32, align 4\l  %4 = alloca i32, align 4\l  %5 = alloca i32, align 4\l  store i32 %0, i32* %4, align 4\l  store i32 %1, i32* %5, align 4\l  %6 = load i32, i32* %4, align 4\l  %7 = srem i32 %6, 5\l  %8 = icmp ne i32 %7, 0\l  br i1 %8, label %9, label %12\l|{<s0>T|<s1>F}}"];
  Node0x7f86c670c590:s0 -> Node0x7f86c65001a0;
  Node0x7f86c670c590:s1 -> Node0x7f86c65001f0;
  Node0x7f86c65001a0 [shape=record,label="{%9:\l\l  %10 = load i32, i32* %4, align 4\l  %11 = mul nsw i32 %10, 10\l  store i32 %11, i32* %3, align 4\l  br label %18\l}"];
  Node0x7f86c65001a0 -> Node0x7f86c65084b0;
  Node0x7f86c65001f0 [shape=record,label="{%12:\l\l  %13 = load i32, i32* %4, align 4\l  %14 = sitofp i32 %13 to float\l  %15 = fpext float %14 to double\l  %16 = call double @llvm.pow.f64(double %15, double 2.500000e+00)\l  %17 = fptosi double %16 to i32\l  store i32 %17, i32* %3, align 4\l  br label %18\l}"];
  Node0x7f86c65001f0 -> Node0x7f86c65084b0;
  Node0x7f86c65084b0 [shape=record,label="{%18:\l\l  %19 = load i32, i32* %3, align 4\l  ret i32 %19\l}"];
  }
"""


def test_DotCfgsFromBytecode_simple_c_program():
  """Test that simple C program produces two Dot CFGs."""
  dot_cfgs = list(llvm_util.DotCfgsFromBytecode(SIMPLE_C_BYTECODE))
  assert len(dot_cfgs) == 2
  assert "CFG for 'DoSomething' function" in '\n'.join(dot_cfgs)
  assert "CFG for 'main' function" in '\n'.join(dot_cfgs)


def test_DotCfgsFromBytecode_invalid_bytecode():
  """Test that exception is raised if bytecode is invalid."""
  with pytest.raises(opt.OptException) as e_ctx:
    next(llvm_util.DotCfgsFromBytecode("invalid bytecode!"))
  assert str(e_ctx.value).startswith("opt failed with return code ")


def test_ControlFlowGraphFromDotSource_invalid_source():
  """Test that exception is raised if dot can't be parsed."""
  with pytest.raises(pyparsing.ParseException):
    llvm_util.ControlFlowGraphFromDotSource("invalid dot source!")


def test_ControlFlowGraphFromDotSource_graph_name():
  """Test that CFG has correct name."""
  g = llvm_util.ControlFlowGraphFromDotSource(SIMPLE_C_DOT)
  assert g.graph['name'] == 'DoSomething'


def test_ControlFlowGraphFromDotSource_num_nodes():
  """Test that CFG has correct number of nodes."""
  g = llvm_util.ControlFlowGraphFromDotSource(SIMPLE_C_DOT)
  assert g.number_of_nodes() == 4


def test_ControlFlowGraphsFromBytecodes_num_graphs():
  """Test that expected number of CFGs are created."""
  g = list(llvm_util.ControlFlowGraphsFromBytecodes([
    SIMPLE_C_BYTECODE,
    SIMPLE_C_BYTECODE,
    SIMPLE_C_BYTECODE,
  ]))

  assert len(g) == 6


def test_ControlFlowGraphsFromBytecodes_one_failure():
  """Errors during construction of CFGs are buffered until complete."""
  # The middle job of the three will throw an opt.optException.
  generator = llvm_util.ControlFlowGraphsFromBytecodes([
    SIMPLE_C_BYTECODE,
    "Invalid bytecode!",
    SIMPLE_C_BYTECODE,
  ])

  g = []
  # We can still get all of the valid CFGs out of input[0] and input[2]. The
  # exception from input[1] is will be raised once all processes have completed.
  g.append(next(generator))
  g.append(next(generator))
  g.append(next(generator))
  g.append(next(generator))
  # Instead of StopIteration, an ExceptionBuffer will be thrown, which contains
  # all the that were thrown, along with the inputs that caused the exception.
  with pytest.raises(llvm_util.ExceptionBuffer) as e_ctx:
    next(generator)
  assert len(e_ctx.value.errors) == 1
  assert e_ctx.value.errors[0].input == "Invalid bytecode!"
  assert isinstance(e_ctx.value.errors[0].error, opt.OptException)


def main(argv):
  """Main entry point."""
  if len(argv) > 1:
    raise app.UsageError("Unknown arguments: '{}'.".format(' '.join(argv[1:])))
  sys.exit(pytest.main([__file__, '-vv']))


if __name__ == '__main__':
  flags.FLAGS(['argv[0]', '-v=1'])
  app.run(main)
